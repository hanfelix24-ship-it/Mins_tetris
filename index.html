<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›¹ í…ŒíŠ¸ë¦¬ìŠ¤ (Web Tetris)</title>
    <meta property="og:title" content="ì•„ë¹ ê°€ ë§Œë“  í…ŒíŠ¸ë¦¬ìŠ¤">
    <meta property="og:description" content="ì¹œêµ¬ì™€ í•¨ê»˜ ì¦ê¸°ëŠ” 2ì¸ìš© ì›¹ í…ŒíŠ¸ë¦¬ìŠ¤! ëª¨ë°”ì¼ í„°ì¹˜ ì§€ì›.">
    <meta property="og:type" content="website">
    <style>
        body {
            background: linear-gradient(to bottom, #ffdde1, #ee9ca7); /* ë‹¬ì½¤í•œ ë°°ê²½ */
            color: #5d4037; /* ì´ˆì½œë¦¿ìƒ‰ í…ìŠ¤íŠ¸ */
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            min-height: 100vh;
            margin: 0;
            touch-action: none; /* ëª¨ë°”ì¼ ìŠ¤í¬ë¡¤/ì¤Œ ë°©ì§€ */
        }

        #game-container {
            display: flex;
            gap: 20px;
        }

        canvas {
            display: block;
            background-color: #FFF5E1; /* í¬ë¦¼ìƒ‰ ë°°ê²½ */
            border: 8px solid #ff80ab; /* ë¶„í™ìƒ‰ í…Œë‘ë¦¬ */
            border-radius: 15px; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.6);
        }

        #score-board {
            font-size: 24px;
            margin-bottom: 10px;
            text-align: center;
        }

        .controls {
            margin-top: 15px;
            font-size: 14px;
            color: #5d4037;
            text-align: center;
        }

        #leaderboard {
            margin-top: 20px;
            text-align: center;
        }
        #leaderboard h3 {
            margin: 0 0 10px 0;
            color: #d81b60;
        }
        #leaderboard ol {
            display: inline-block;
            text-align: left;
            padding-left: 20px;
        }

        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ */
        .mobile-controls {
            display: flex; /* ëª¨ë°”ì¼ ì „ìš©ì´ë¯€ë¡œ í•­ìƒ í‘œì‹œ */
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            touch-action: manipulation;
        }

        .control-btn {
            width: 55px; /* S22 Ultra í­ì— ë§ê²Œ ì¡°ì • */
            height: 55px;
            background: rgba(255, 255, 255, 0.4);
            border: 2px solid #5d4037;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            color: #5d4037;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.8);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            #game-container {
                flex-direction: column;
            }
            .mobile-controls {
                display: flex;
            }
            .controls {
                display: none;
            }
        }
    </style>
</head>
<body>

    <div id="score-board">
        Score: <span id="score1">0</span>
    </div>
    
    <div id="game-container">
        <canvas id="tetris1" width="240" height="400"></canvas>
    </div>

    <!-- ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ -->
    <div class="mobile-controls">
        <div class="control-btn" id="btn-left">â†</div>
        <div class="control-btn" id="btn-down">â†“</div>
        <div class="control-btn" id="btn-right">â†’</div>
        <div class="control-btn" id="btn-rotate">â†»</div>
        <div class="control-btn" id="btn-hard-drop">â¤“</div>
        <div class="control-btn" id="btn-pause" style="font-size: 16px;">âšâš</div>
    </div>

    <div class="controls">
        <p>ë°©í–¥í‚¤: ì´ë™/íšŒì „ | Space: í•˜ë“œë“œë¡­ | ESC: ì¼ì‹œì •ì§€</p>
    </div>

    <div id="leaderboard">
        <h3>ğŸ† Hall of Fame ğŸ†</h3>
        <ol id="rank-list"></ol>
    </div>

    <script>
        // í…ŒíŠ¸ë¦¬ìŠ¤ ì¡°ê°(Tetromino) ì •ì˜
        function createPiece(type) {
            if (type === 'I') {
                return [
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                    [0, 1, 0, 0],
                ];
            } else if (type === 'L') {
                return [
                    [0, 2, 0],
                    [0, 2, 0],
                    [0, 2, 2],
                ];
            } else if (type === 'J') {
                return [
                    [0, 3, 0],
                    [0, 3, 0],
                    [3, 3, 0],
                ];
            } else if (type === 'O') {
                return [
                    [4, 4],
                    [4, 4],
                ];
            } else if (type === 'Z') {
                return [
                    [5, 5, 0],
                    [0, 5, 5],
                    [0, 0, 0],
                ];
            } else if (type === 'S') {
                return [
                    [0, 6, 6],
                    [6, 6, 0],
                    [0, 0, 0],
                ];
            } else if (type === 'T') {
                return [
                    [0, 7, 0],
                    [7, 7, 7],
                    [0, 0, 0],
                ];
            }
        }

        // ê²Œì„ ë³´ë“œ(Arena) ìƒì„±
        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        // ì¶©ëŒ ê°ì§€ ë¡œì§
        function collide(arena, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        // í™”ë©´ ê·¸ë¦¬ê¸°
        function draw(player) {
            // ë°°ê²½ì„ í¬ë¦¼ìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™”
            player.context.fillStyle = '#FFF5E1';
            player.context.fillRect(0, 0, player.canvas.width, player.canvas.height);
            drawGrid(player.context);

            drawMatrix(player.arena, {x: 0, y: 0}, player.context);
            drawMatrix(player.matrix, player.pos, player.context);
        }

        // ê°€ì´ë“œ ë¼ì¸ ê·¸ë¦¬ê¸° (3ì¹¸ ê°„ê²© ì ì„ )
        function drawGrid(context) {
            context.beginPath();
            context.strokeStyle = 'rgba(93, 64, 55, 0.2)'; // ì´ˆì½œë¦¿ìƒ‰, ì—°í•˜ê²Œ
            context.lineWidth = 0.05;
            context.setLineDash([0.2, 0.2]); // ì ì„  íŒ¨í„´

            // ì„¸ë¡œì„  (3ì¹¸ ê°„ê²©)
            for (let x = 3; x < 12; x += 3) {
                context.moveTo(x, 0);
                context.lineTo(x, 20);
            }

            // ê°€ë¡œì„  (3ì¹¸ ê°„ê²©)
            for (let y = 3; y < 20; y += 3) {
                context.moveTo(0, y);
                context.lineTo(12, y);
            }
            context.stroke();
            context.setLineDash([]); // ì ì„  ì´ˆê¸°í™”
        }

        // í–‰ë ¬(ë¸”ë¡) ê·¸ë¦¬ê¸°
        function drawMatrix(matrix, offset, context) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // ê³¼ì/ì ¤ë¦¬ ìƒ‰ìƒ ì„¤ì •
                        const colors = [
                            null,
                            '#FF6B81', // I - ë”¸ê¸°ë§›
                            '#FFA502', // L - ì˜¤ë Œì§€ë§›
                            '#1E90FF', // J - ë¸”ë£¨ë² ë¦¬ë§›
                            '#F1C40F', // O - ë ˆëª¬ë§›
                            '#2ECC71', // Z - ì‚¬ê³¼ë§›
                            '#9B59B6', // S - í¬ë„ë§›
                            '#E056FD', // T - ë¼ì¦ˆë² ë¦¬ë§›
                        ];
                        context.fillStyle = colors[value];
                        
                        // ì ¤ë¦¬ ëŠë‚Œì˜ ë¸”ë¡ ê·¸ë¦¬ê¸°
                        const cx = x + offset.x;
                        const cy = y + offset.y;

                        // ë©”ì¸ ë°”ë”” (ì•½ê°„ ì‘ê²Œ ê·¸ë ¤ì„œ í‹ˆì„ ì¤Œ)
                        context.fillRect(cx + 0.05, cy + 0.05, 0.9, 0.9);
                        
                        // ê´‘íƒ íš¨ê³¼ (ì™¼ìª½ ìƒë‹¨ í•˜ì´ë¼ì´íŠ¸)
                        context.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        context.fillRect(cx + 0.1, cy + 0.1, 0.3, 0.3);

                        // í…Œë‘ë¦¬ (ë¶€ë“œëŸ½ê²Œ)
                        context.lineWidth = 0.05;
                        context.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        context.strokeRect(cx + 0.05, cy + 0.05, 0.9, 0.9);
                    }
                });
            });
        }

        // í”Œë ˆì´ì–´ ë¸”ë¡ì„ ê²Œì„ ë³´ë“œì— í•©ì¹˜ê¸°
        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        // í–‰ë ¬ íšŒì „
        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) {
                matrix.forEach(row => row.reverse());
            } else {
                matrix.reverse();
            }
        }

        // í”Œë ˆì´ì–´ ë¸”ë¡ ë–¨ì–´ëœ¨ë¦¬ê¸°
        function playerDrop(player) {
            player.pos.y++;
            if (collide(player.arena, player)) {
                player.pos.y--;
                merge(player.arena, player);
                playerReset(player);
                arenaSweep(player);
                updateScore(player);
            }
            player.dropCounter = 0;
        }

        // í”Œë ˆì´ì–´ ì´ë™
        function playerMove(player, offset) {
            player.pos.x += offset;
            if (collide(player.arena, player)) {
                player.pos.x -= offset;
            }
        }

        // í”Œë ˆì´ì–´ ì´ˆê¸°í™” ë° ìƒˆ ë¸”ë¡ ìƒì„±
        function playerReset(player) {
            const pieces = 'ILJOTSZ';
            player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
            player.pos.y = 0;
            player.pos.x = (player.arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            
            // ìƒì„±í•˜ìë§ˆì ì¶©ëŒí•˜ë©´ ê²Œì„ ì˜¤ë²„
            if (collide(player.arena, player)) {
                player.arena.forEach(row => row.fill(0));
                player.score = 0;
                updateScore(player);
            }
        }

        // í”Œë ˆì´ì–´ íšŒì „ ì²˜ë¦¬
        function playerRotate(player, dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            // ë²½ ì°¨ê¸° (Wall Kick) êµ¬í˜„: íšŒì „ ì‹œ ë²½ì— ê²¹ì¹˜ë©´ ë°€ì–´ë‚´ê¸°
            while (collide(player.arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }

        // í•˜ë“œ ë“œë¡­ (ë°”ë¡œ ë°”ë‹¥ìœ¼ë¡œ ë–¨ì–´ëœ¨ë¦¬ê¸°)
        function playerHardDrop(player) {
            while (!collide(player.arena, player)) {
                player.pos.y++;
            }
            player.pos.y--;
            merge(player.arena, player);
            playerReset(player);
            arenaSweep(player);
            updateScore(player);
            player.dropCounter = 0;
        }

        // ì¤„ ì‚­ì œ ë° ì ìˆ˜ ê³„ì‚°
        function arenaSweep(player) {
            let rowCount = 1;
            outer: for (let y = player.arena.length - 1; y > 0; --y) {
                for (let x = 0; x < player.arena[y].length; ++x) {
                    if (player.arena[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = player.arena.splice(y, 1)[0].fill(0);
                player.arena.unshift(row);
                ++y;

                player.score += rowCount * 10;
                rowCount *= 2;
            }
        }

        function updateScore(player) {
            player.scoreElement.innerText = player.score;
            
            // 100ì  ì´ˆê³¼ ì‹œ ì†ë„ 1.5ë°° ì¦ê°€ (ê¸°ë³¸ 1000ms -> ì•½ 666ms)
            if (player.score > 100) {
                player.dropInterval = 1000 / 1.5;
            }

            if (player.score >= 150 && !gameOver) {
                gameOver = true;
                setTimeout(() => {
                    const name = (player === player1 ? 'Player 1' : 'Player 2');
                    const name = 'Player';
                    let initials = prompt(`${name} ìŠ¹ë¦¬! ì´ë‹ˆì…œ 3ê¸€ìë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ABC):`);
                    if (!initials) initials = "UNK";
                    saveScore(initials.toUpperCase().substring(0, 3), player.score);
                }, 10);
            }
        }

        function saveScore(name, score) {
            let ranks = JSON.parse(localStorage.getItem('tetris_ranks') || '[]');
            ranks.push({name, score});
            ranks.sort((a, b) => b.score - a.score);
            ranks = ranks.slice(0, 3); // ìƒìœ„ 3ë“±ê¹Œì§€ë§Œ ìœ ì§€
            localStorage.setItem('tetris_ranks', JSON.stringify(ranks));
            displayLeaderboard();
        }

        function displayLeaderboard() {
            const list = document.getElementById('rank-list');
            list.innerHTML = '';
            const ranks = JSON.parse(localStorage.getItem('tetris_ranks') || '[]');
            ranks.forEach((r, index) => {
                const li = document.createElement('li');
                li.innerText = `${index + 1}ë“±: ${r.name} - ${r.score}ì `;
                list.appendChild(li);
            });
        }

        // ê²Œì„ ë£¨í”„ ë³€ìˆ˜
        let lastTime = 0;
        let gameOver = false;
        let isPaused = false;

        // ê²Œì„ ë£¨í”„
        function update(time = 0) {
            if (gameOver) return;
            if (isPaused) {
                lastTime = time;
                requestAnimationFrame(update);
                return;
            }
            const deltaTime = time - lastTime;
            lastTime = time;

            [player1].forEach(player => {
                player.dropCounter += deltaTime;
                if (player.dropCounter > player.dropInterval) {
                    playerDrop(player);
                }
                draw(player);
            });
            
            requestAnimationFrame(update);
        }

        // í”Œë ˆì´ì–´ ìƒì„± í•¨ìˆ˜
        function createPlayer(elementId, scoreId) {
            const element = document.getElementById(elementId);
            const context = element.getContext('2d');
            context.scale(20, 20);
            return {
                pos: {x: 0, y: 0},
                matrix: null,
                score: 0,
                arena: createMatrix(12, 20),
                canvas: element,
                context: context,
                scoreElement: document.getElementById(scoreId),
                dropCounter: 0,
                dropInterval: 1000,
            };
        }

        const player1 = createPlayer('tetris1', 'score1');
        const player2 = createPlayer('tetris2', 'score2');

        function togglePause() {
            if (gameOver) return;
            isPaused = !isPaused;
            
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = isPaused ? 'â–¶' : 'âšâš';

            if (isPaused) {
                [player1].forEach(p => {
                    p.context.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    p.context.fillRect(0, 0, 12, 20);
                    p.context.fillStyle = '#5d4037';
                    p.context.font = '1px sans-serif';
                    p.context.textAlign = 'center';
                    p.context.fillText("PAUSED", 6, 10);
                });
            } else {
                // ì¬ê°œ ì‹œ ì¦‰ì‹œ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
                draw(player1);
                draw(player2);
            }
        }

        // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
        document.addEventListener('keydown', event => {
            if (gameOver) return;
            if (event.keyCode === 27) { // ESC
                togglePause();
            }

            if (gameOver || isPaused) return;

            // Player 1 Controls (Arrows)
            if (event.keyCode === 37) { // Left
                playerMove(player1, -1);
            } else if (event.keyCode === 39) { // Right
                playerMove(player1, 1);
            } else if (event.keyCode === 40) { // Down
                playerDrop(player1);
            } else if (event.keyCode === 38) { // Up (Rotate)
                playerRotate(player1, 1);
            } else if (event.keyCode === 32) { // Space (Hard Drop)
                playerHardDrop(player1);
            }
            
            // Player 2 Controls (WASD)
            if (event.keyCode === 65) { // A
                playerMove(player2, -1);
            } else if (event.keyCode === 68) { // D
                playerMove(player2, 1);
            } else if (event.keyCode === 83) { // S
                playerDrop(player2);
            } else if (event.keyCode === 87) { // W (Rotate)
                playerRotate(player2, 1);
            } else if (event.keyCode === 69) { // E (Hard Drop)
                playerHardDrop(player2);
            }
        });

        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function addTouchListener(id, action) {
            const btn = document.getElementById(id);
            if(btn) {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // í„°ì¹˜ ì‹œ ìŠ¤í¬ë¡¤ ë“± ê¸°ë³¸ ë™ì‘ ë°©ì§€
                    if (!gameOver) action();
                }, {passive: false});
            }
        }

        addTouchListener('btn-left', () => playerMove(player1, -1));
        addTouchListener('btn-right', () => playerMove(player1, 1));
        addTouchListener('btn-down', () => playerDrop(player1));
        addTouchListener('btn-rotate', () => playerRotate(player1, 1));
        addTouchListener('btn-hard-drop', () => playerHardDrop(player1));
        addTouchListener('btn-pause', () => togglePause());

        playerReset(player1);
        playerReset(player2);
        updateScore(player1);
        updateScore(player2);
        displayLeaderboard();
        update();
    </script>
</body>
</html>
